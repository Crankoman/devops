# Домашнее задание к занятию "6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

<--

Ответ:

Будем использовать консольную утилиту `mongosh` https://www.mongodb.com/docs/manual/reference/method/
Найдем самую долгую операцию из тех что сейчас выполняются больше 3 минут https://www.mongodb.com/docs/manual/reference/method/db.currentOp/
```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 }
   }
)
```

Ответ будет содержать
```
{
  "inprog": [
       {
         "opid" : <number>,
   ]
}
```

Остановим операцию https://www.mongodb.com/docs/manual/reference/method/db.killOp/#mongodb-method-db.killOp
```
db.killOp(<opid of the query to kill>)
```

Для вычленения долгих запросов необходимо включить профилирование https://www.mongodb.com/docs/manual/tutorial/manage-the-database-profiler/#std-label-database-profiling-level

```
db.setProfilingLevel(1, { slowms: <operation time threshold, in milliseconds, beyond which operations are considered slow> })
```
И указать что бы все операции дольше заданного времени писались в лог профилирования

Далее следует анализ данных запросов для выявления причин и способа устранения (изменение запроса, использование индексов и т.д.)

---

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

<--

Ответ:

Судя по документации речь идет о Latency generated by expires https://redis.io/docs/management/optimization/latency/#latency-generated-by-expires
Скорее всего произошла ситуация когда слишком большое количество ключей в секунду истекает и Redis блокирует запись,
что бы удержать количество просроченных ключей менее 25% и не раздувать потребляемую память.
Я бы еще проверил канал связи между нодами кластера.

---

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

<--

Ответ:

Судя по документации https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html и тому проблема начала появляться после роста количества записей в таблице
проблема может быть вызвана, что время ответа на отправленный запрос сервера превышает время ожидания ответа от клиента (так как он не успел получить большой по размеру ответ). Определяется директивой `net_read_timeout` 30 секунд по умолчанию.
Быстрое решение увеличить данный таймаут, но правильный это разбить запрос, например используя LIMIT.
Так же надо проверить пропускную способность и стабильность канала от клиента до сервера.


---

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

<--

Ответ:

Судя по документации https://www.postgresql.org/docs/current/kernel-resources.html речь идет о ситуации когда кончилась доступная оперативная/виртуальная память. Ядро ОС отключает приложение, что бы продолжить функционирование.
В таком случае хотя существующие подключения к базе данных будут продолжать функционировать нормально, новые подключения приниматься не будут. Для восстановления PostgreSQL потребуется перезапустить.
Решений проблемы может быть несколько от указания лимитов на использование памяти PostgreSQL, включения/увеличения файла подкачки(swap), увеличении доступной памяти (увеличение памяти в ВМ или перенос на отдельный сервер). Так же можно снизить потребление памяти уменьшив директивы `shared_buffers`, `work_mem`, `hash_mem_multiplier`
и количество поддерживаемых подключений `max_connections` (например используя pgbouncer). Так же можно изменить поведение ядра Linux, но это плохая идея.

---
